# [0016. 顺序结构](https://github.com/tnotesjs/TNotes.c-cpp/tree/main/notes/0016.%20%E9%A1%BA%E5%BA%8F%E7%BB%93%E6%9E%84)

<!-- region:toc -->

- [1. 🎯 本节内容](#1--本节内容)
- [2. 🫧 评价](#2--评价)
- [3. 🤔 什么是顺序结构？](#3--什么是顺序结构)
- [4. 🤔 为什么顺序结构是程序设计的基础？](#4--为什么顺序结构是程序设计的基础)
- [5. 🤔 顺序结构中语句的执行顺序由什么决定？](#5--顺序结构中语句的执行顺序由什么决定)
- [6. 🤔 变量定义、赋值和 I/O 操作在顺序结构中如何组织？](#6--变量定义赋值和-io-操作在顺序结构中如何组织)
- [7. 🆚 顺序结构 vs 控制结构（分支/循环）的本质区别是什么？](#7--顺序结构-vs-控制结构分支循环的本质区别是什么)
- [8. 🤔 顺序结构能否被优化或重排？编译器会改变执行顺序吗？](#8--顺序结构能否被优化或重排编译器会改变执行顺序吗)
- [9. 🔗 引用](#9--引用)

<!-- endregion:toc -->

## 1. 🎯 本节内容

- 顺序结构
- 语句序列
- 表达式求值
- 语句执行顺序
- 副作用
- 可观察行为
- 优化与重排
- 与分支循环的对比

## 2. 🫧 评价

- 顺序结构看起来“没东西”，但它决定了你如何组织代码与验证结果。
- 很多初学者问题并不是语法错，而是对执行顺序与副作用缺少直觉。

## 3. 🤔 什么是顺序结构？

顺序结构是最基本的程序结构之一，指的是：程序按源代码中语句出现的先后顺序，依次执行。

它不引入额外的分支路径，也不重复执行某一段逻辑。你可以把它理解为一条直线式的控制流。

::: code-group

```c [顺序结构示例]
#include <stdio.h>

int main(void) {

  int a = 1;
  int b = 2;
  int c = a + b;

  printf("c=%d\n", c);
  return 0;
}
```

:::

上面的程序没有 `if`、`switch`、循环，也没有跳转语句，执行路径只有一条。

## 4. 🤔 为什么顺序结构是程序设计的基础？

无论你写的是分支还是循环，最终都可以拆解为若干段顺序执行的语句序列。

从工程角度看，顺序结构的重要性主要体现在三点：

1. 可读性：直线代码最容易读懂，也最容易定位问题。
2. 可测试性：顺序代码的输入输出关系更清晰，更容易做断言与单元测试。
3. 可维护性：当控制流复杂时，把逻辑拆成多个“顺序段”，往往能显著降低复杂度。

很多代码风格建议，实际上都是在帮你把控制流“拉直”，例如：早返回、提取函数、减少嵌套。

## 5. 🤔 顺序结构中语句的执行顺序由什么决定？

在顺序结构里，语句的执行顺序由“语句在源代码中出现的顺序”决定。

但是要注意两层容易混淆的顺序：

- 语句执行顺序：这一条通常非常明确，按顺序执行。
- 表达式求值顺序：同一条语句内部，多个子表达式的求值顺序可能并不固定。

例如，下面这行代码虽然是“一个语句”，但 `f()` 和 `g()` 的求值先后次序并不由你肉眼看到的左右位置保证。

::: code-group

```c [⚠️ 表达式求值顺序不等于从左到右]
int f(void);
int g(void);

int x = f() + g();
// ⚠️ 不要依赖 f 和 g 谁先执行。
```

:::

工程建议是：

- 不要把多个带副作用的操作塞进同一个表达式。
- 把关键步骤拆成多条顺序语句，让顺序可见。

## 6. 🤔 变量定义、赋值和 I/O 操作在顺序结构中如何组织？

顺序结构最常见的组织方式是：

1. 声明与初始化：把变量的定义放在靠近使用的位置，并初始化为合理值。
2. 计算与赋值：用清晰的中间变量表达意图，避免“神秘的一行”。
3. 输入与校验：先读入，再验证，再使用。
4. 输出与收尾：输出结果，释放资源，返回状态码。

::: code-group

```c [✅ 顺序结构的常见组织]
#include <stdio.h>

int main(void) {

  int a;
  int b;

  printf("请输入两个整数：");
  if (scanf("%d %d", &a, &b) != 2) {
    fprintf(stderr, "输入格式不正确。\n");
    return 1;
  }

  int sum = a + b;
  int diff = a - b;

  printf("sum=%d，diff=%d\n", sum, diff);
  return 0;
}
```

```c [⚠️ 不推荐：把副作用堆在一起]
int i = 0;
int x = i++ + ++i;
// ⚠️ 对同一变量多次修改且缺少明确的排序关系，行为未定义。
```

:::

如果你确实需要一个步骤依赖另一个步骤的结果，就用顺序语句显式表达出来。

## 7. 🆚 顺序结构 vs 控制结构（分支/循环）的本质区别是什么？

顺序结构是一条直线控制流，而分支与循环会让控制流出现“路径”与“重复”。

| 维度                   | 顺序结构             | 分支结构   | 循环结构       |
| ---------------------- | -------------------- | ---------- | -------------- |
| 执行路径               | 单一路径             | 多路径择一 | 路径重复执行   |
| 是否可能不执行某段代码 | 很少，基本都会执行   | 可能       | 可能           |
| 是否可能执行多次       | 不会                 | 不会       | 会             |
| 典型用途               | 计算与数据处理流水线 | 条件决策   | 重复处理与遍历 |

理解这个区别的意义在于：当你调试程序时，顺序结构更像“流水线”，分支像“岔路”，循环像“回环”。

工程实践里，很多复杂逻辑可以通过拆分函数、引入早返回，把整体控制流重新组织成多个较短的顺序段。

## 8. 🤔 顺序结构能否被优化或重排？编译器会改变执行顺序吗？

从源代码视角看，顺序结构按语句顺序执行。

但在编译器优化层面，编译器可能在不改变程序“可观察行为”的前提下，对指令进行重排、合并或消除。

这里的关键在于“可观察行为”，典型包括：

- 对外部 I/O 的影响，例如打印输出、文件读写。
- 对 `volatile` 对象的读写。
- 与信号、线程等相关的可观察效果。

因此你通常可以相信：

- 两条有 I/O 依赖关系的语句，其对外部世界的效果不会被随意交换。
- 但同一条语句内部的子表达式求值顺序，仍然不应依赖。

::: code-group

```c [✅ 用顺序语句固定副作用顺序]
int i = 0;
int a = i;
i++;
int b = i;
// 这里的顺序是明确的，可读性也更好。
```

:::

如果你写的是硬件寄存器访问或并发相关代码，顺序与重排会更敏感，需要使用 `volatile`、原子操作或同步原语，并遵循相应平台与标准的约束。

## 9. 🔗 引用

- [cppreference：Statements，C 语句概览][1]
- [cppreference：Expression evaluation，表达式求值顺序][2]
- [cppreference：volatile type qualifier][3]

[1]: https://en.cppreference.com/w/c/language/statements
[2]: https://en.cppreference.com/w/c/language/eval_order
[3]: https://en.cppreference.com/w/c/language/volatile
