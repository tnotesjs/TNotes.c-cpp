# [0006. 程序设计语言简介](https://github.com/tnotesjs/TNotes.c-cpp/tree/main/notes/0006.%20%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80%E7%AE%80%E4%BB%8B)

<!-- region:toc -->

- [1. 🎯 本节内容](#1--本节内容)
- [2. 🫧 评价](#2--评价)
- [3. 🤔 什么是程序设计语言？](#3--什么是程序设计语言)
- [4. 🤔 程序设计语言如何分类？](#4--程序设计语言如何分类)
  - [4.1. 按抽象层次](#41-按抽象层次)
  - [4.2. 按实现方式](#42-按实现方式)
  - [4.3. 按程序设计思想](#43-按程序设计思想)
- [5. 🆚 机器语言 vs 汇编语言 vs 高级语言？](#5--机器语言-vs-汇编语言-vs-高级语言)
- [6. 🤔 为什么 C 等某些高级语言被称为面向过程语言？](#6--为什么-c-等某些高级语言被称为面向过程语言)
- [7. 🤔 什么是源程序、目标程序和可执行程序？](#7--什么是源程序目标程序和可执行程序)
- [8. 🤔 高级语言要如何才能执行？](#8--高级语言要如何才能执行)
- [9. 🆚 常见编程语言执行方式对比](#9--常见编程语言执行方式对比)
  - [9.1. 纯解释执行](#91-纯解释执行)
  - [9.2. 编译执行](#92-编译执行)
  - [9.3. 混合型（编译 + 解释 / JIT）](#93-混合型编译--解释--jit)
  - [9.4. 小结](#94-小结)
- [10. 🤔 编译过程的详细步骤是什么？](#10--编译过程的详细步骤是什么)
  - [10.1. 详细步骤](#101-详细步骤)
    - [第 1 步：预处理](#第-1-步预处理)
    - [第 2 步：编译](#第-2-步编译)
    - [第 3 步：汇编](#第-3-步汇编)
    - [第 4 步：链接](#第-4-步链接)
  - [10.2. 小结](#102-小结)
- [11. 🤔 C/C++ 在编程语言谱系中的位置？](#11--cc-在编程语言谱系中的位置)
- [12. 🤔 为什么需要多种编程语言？](#12--为什么需要多种编程语言)

<!-- endregion:toc -->

## 1. 🎯 本节内容

- 程序设计语言简介

## 2. 🫧 评价

本节内容不是很重要，大多是一些概念性的内容，理解这些概念，可以适当加深我们对 C/C++ 语言的理解。

## 3. 🤔 什么是程序设计语言？

程序设计语言是一种用来精确描述计算过程的形式化语言，用于把人类的求解思路变成计算机可以执行的指令。

从开发者视角看，程序设计语言至少承担三种角色：

- 交流媒介：把人类对问题求解的思路表达成代码。
- 形式规范：通过严格的语法和语义规则避免歧义。
- 执行抽象：提供从问题域到机器执行的抽象层次，最终通过编译器、解释器或运行时环境将代码转换为可在硬件上执行的指令。

一门成熟的程序设计语言通常同时关注下面几个方面：

- 可读性：便于人理解和维护。
- 可表达性：能简洁表达常见的数据结构和算法。
- 可实现性：易于编译成高效、可靠的机器指令。

## 4. 🤔 程序设计语言如何分类？

程序设计语言可以从多个维度进行分类，常见的维度包括：

### 4.1. 按抽象层次

- 机器语言：直接由二进制指令组成，面向硬件。
- 汇编语言：使用助记符表达指令，需要汇编器翻译成机器码。
- 高级语言：面向人类表达问题，需要编译或解释后才能执行。

### 4.2. 按实现方式

- 编译型：先整体翻译成目标程序，再运行，如传统的 C 语言、C++。
- 解释型：运行时逐条分析并执行源代码，如早期的脚本语言。
- 混合型：编译与解释结合，如先编译为中间表示，再由虚拟机执行。

### 4.3. 按程序设计思想

- 面向过程语言：强调过程与函数的划分。
- 面向对象语言：强调对象、抽象、继承、多态。
- 函数式语言：强调函数是一等公民，提倡无副作用。

实际语言往往同时具备多种特征，例如 C++ 既支持面向过程编程，也支持面向对象和一定程度的泛型与函数式风格。

## 5. 🆚 机器语言 vs 汇编语言 vs 高级语言？

从开发者视角比较这三类语言时，可以关注下表中的差异：

| 特性 | 机器语言 | 汇编语言 | 高级语言 |
| --- | --- | --- | --- |
| 可读性 | 极差，二进制难以理解 | 较差，需要熟悉指令集 | 较好，更接近自然语言和数学表达式 |
| 编写效率 | 很低 | 低 | 高 |
| 可移植性 | 几乎没有，绑定具体硬件 | 较差，仍依赖处理器指令集 | 较好，可通过不同编译器适配多种平台 |
| 控制粒度 | 极细粒度，直接操作硬件 | 细粒度，便于精确优化 | 相对粗粒度，由编译器负责底层细节 |
| 典型用途 | 引导程序、固件 | 驱动程序、性能关键内核代码 | 应用程序、库开发、跨平台业务系统 |

在实际工程中，通常只在极少数对性能和资源极端敏感的场景下手写机器语言或汇编语言，绝大多数应用采用高级语言来提高生产力。

## 6. 🤔 为什么 C 等某些高级语言被称为面向过程语言？

早期的许多高级语言，如 C，常被称为面向过程语言，是因为它们以过程也就是函数作为组织程序的基本单元。

面向过程语言的典型特点包括：

- 程序被拆分为若干函数或过程，每个函数完成一个相对独立的子任务。
- 数据通常通过参数传递或全局变量在函数之间流动。
- 关注点在于先后执行的步骤，即做什么、以什么顺序做。

与之相比，面向对象语言更强调对象及其状态，把数据和操作封装在一起，通过对象之间的协作来完成任务。现代 C++ 同时支持面向过程和面向对象两种风格。

## 7. 🤔 什么是源程序、目标程序和可执行程序？

在编译型语言的开发流程中，常见的几个概念如下：

- 源程序：由程序设计语言编写的文本文件，例如 C 或 C++ 源文件，通常以 C 或 `cpp` 等扩展名结尾。
- 目标程序：由编译器将源程序翻译后生成的中间二进制文件，一般尚未与库链接，不能直接运行。
- 可执行程序：将一个或多个目标程序与所需库链接之后得到的最终二进制文件，可以在操作系统中直接运行。

从开发者编写第一行代码，到用户双击运行，中间就经历了从源程序到目标程序再到可执行程序的转换过程。

## 8. 🤔 高级语言要如何才能执行？

把高级语言的源码变成可以运行的形式，大致有两条路：

- 解释执行：翻译器在程序运行时逐条读取源代码，解析语法，并立即执行对应的操作，不生成独立的可执行文件。
- 预先编译：编译器在运行前一次性把源程序翻译成目标程序或可执行程序，之后的运行过程只依赖生成的二进制文件。

很多现代语言采用的是编译和解释结合的方式，例如先编译为中间表示，再由虚拟机解释或即时编译执行。

下面的图示意性地对比了解释执行和编译执行两种路径：

![2](./assets/2.svg)

## 9. 🆚 常见编程语言执行方式对比

### 9.1. 纯解释执行

| 语言示例 | 执行特点 | 代表实现 | 说明 |
| --- | --- | --- | --- |
| Python | 逐行解释执行源代码 | CPython | 标准实现为解释执行，但有 PyPy 等 JIT 优化版本 |
| Ruby | 逐行解释执行 | MRI (Matz's Ruby Interpreter) | 也有 JIT 实现如 TruffleRuby |
| PHP | 服务器端脚本解释执行 | Zend Engine | 现代 PHP 有 OPcache 进行字节码缓存 |
| JavaScript | 传统上浏览器中解释执行 | SpiderMonkey (Firefox) | 现代浏览器均采用 JIT 编译 |

### 9.2. 编译执行

| 语言示例 | 执行特点         | 代表实现    | 说明                          |
| -------- | ---------------- | ----------- | ----------------------------- |
| C        | 直接编译为机器码 | GCC, Clang  | 传统编译型语言代表            |
| C++      | 直接编译为机器码 | GCC, MSVC   | 编译后生成本地可执行文件      |
| Go       | 直接编译为机器码 | Go compiler | 静态编译，生成独立可执行文件  |
| Rust     | 直接编译为机器码 | rustc       | 基于 LLVM，编译为高效本地代码 |

### 9.3. 混合型（编译 + 解释 / JIT）

| 语言示例 | 执行特点 | 代表实现 | 说明 |
| --- | --- | --- | --- |
| Java | 编译为字节码，JVM 执行 | HotSpot JVM | 采用 JIT 编译技术，热点代码会被编译为机器码 |
| C# | 编译为 IL，CLR 执行 | .NET Runtime | 现代 .NET 使用 RyuJIT 进行即时编译 |
| Kotlin | 编译为 JVM 字节码或 JS | Kotlin/JVM | 多平台目标：JVM、JS、Native |
| Scala | 编译为 JVM 字节码 | Scala Compiler | 运行在 JVM 上，利用 JIT 优化 |
| Python | 编译为字节码，解释执行 | PyPy | 使用 JIT 编译器提升性能 |

### 9.4. 小结

执行方式的模糊边界：

- 现代语言往往结合多种技术，如 JavaScript 在 V8 引擎中使用 TurboFan JIT 编译器
- Python 的 PyPy 实现使用 JIT 编译，性能远超标准 CPython 解释器

关键区别：

- 纯解释执行：无编译步骤，直接解释源代码
- 传统编译：生成独立的可执行文件，无需源代码即可运行
- 混合型：先编译为中间表示，再由运行时环境处理

性能考量：

- 编译型语言通常启动快、执行效率高
- 解释型语言开发调试更便捷，跨平台性更好
- 混合型语言通过 JIT 在运行时优化，可达到接近编译型语言的性能

注意：

- 同一语言可能有多种实现方式，如 Python 可以是解释执行 (CPython)，也可以是 JIT 编译 (PyPy)，因此执行方式不能完全定义一门语言，而更多取决于其实现。
- 比如直接说“Python 是解释型语言”是不准确的，因为它有多种实现方式。
- 更准确的说法：
  - Python 语言可以有多种执行方式，具体取决于所使用的实现
  - CPython 是 Python 的一个解释执行实现
  - Python 的标准实现（CPython） 采用编译为字节码后解释执行的方式来运行 Python 代码
  - Python 通常以混合方式执行：先编译为中间表示，再由运行时环境处理
  - ……

## 10. 🤔 编译过程的详细步骤是什么？

### 10.1. 详细步骤

![1](./assets/1.svg)

以 C 语言、C++ 这样的传统编译型语言为例，一个源文件从文本到可执行程序通常要经过以下几个阶段：

#### 第 1 步：预处理

- 处理宏定义、条件编译、头文件包含等指令。
- 输出仍然是文本形式的中间源代码。

#### 第 2 步：编译

- 对经过预处理的源代码进行词法分析、语法分析、语义分析。
- 生成与架构无关的中间表示（IR），再转换为与具体架构相关的汇编代码。

#### 第 3 步：汇编

- 将汇编代码转换成机器指令。
- 生成二进制形式的目标文件。

#### 第 4 步：链接

- 把多个目标文件以及标准库或第三方库中的目标代码合并。
- 解决符号引用，最终生成可执行程序或可加载的库文件。

### 10.2. 小结

多数编译器会把这些步骤封装在一个命令内部，但理解各阶段的职责有助于排查编译和链接错误。

## 11. 🤔 C/C++ 在编程语言谱系中的位置？

C 和 C++ 在编程语言谱系中大致处于下面的位置：

- 抽象层次上：介于汇编语言和现代高级语言之间，既能贴近硬件，又提供较强的抽象能力。
- 实现方式上：典型的编译型语言，通过编译和链接生成高效的本地机器码。
- 编程范式上：C 偏向面向过程，C++ 在此基础上引入面向对象、泛型编程等多种范式。
- 应用领域上：广泛用于系统软件、编译器、库开发、游戏引擎、高性能服务等对性能和资源有高要求的场景。

可以把 C 看作是许多现代语言的基石，而 C++ 则在兼容 C 的前提下持续扩展语言特性和标准库能力。

## 12. 🤔 为什么需要多种编程语言？

现实世界的计算问题非常多样，一门语言很难在所有维度上同时做到最优，不同语言往往针对不同需求做出权衡。

常见的考量因素包括：

- 性能与资源占用：是否需要尽可能逼近硬件上限。
- 开发效率与可维护性：是否更看重快速交付和易读性。
- 运行环境：是运行在操作系统之上、虚拟机之上，还是直接面向硬件。
- 领域特定需求：是否需要对某个领域提供一流的抽象能力。

因此，工程实践中通常是多种语言协同工作，例如用 C 或 C++ 编写性能关键模块，用更高层的脚本语言编写业务逻辑，再通过接口把各个部分连接起来。
