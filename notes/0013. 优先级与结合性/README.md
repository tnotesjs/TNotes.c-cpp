# [0013. 优先级与结合性](https://github.com/tnotesjs/TNotes.c-cpp/tree/main/notes/0013.%20%E4%BC%98%E5%85%88%E7%BA%A7%E4%B8%8E%E7%BB%93%E5%90%88%E6%80%A7)

<!-- region:toc -->

- [1. 🎯 本节内容](#1--本节内容)
- [2. 🫧 评价](#2--评价)
- [3. 🤔 什么是运算符优先级？它如何影响表达式求值？](#3--什么是运算符优先级它如何影响表达式求值)
- [4. 🤔 什么是结合性？左结合与右结合有何区别？](#4--什么是结合性左结合与右结合有何区别)
- [5. 🤔 为什么 a = b = c 是合法的，而 a + b + c 的求值顺序却不同？](#5--为什么-a--b--c-是合法的而-a--b--c-的求值顺序却不同)
- [6. 🆚 优先级高是否意味着先求值？副作用与求值顺序的关系是什么？](#6--优先级高是否意味着先求值副作用与求值顺序的关系是什么)
- [7. 🤔 哪些运算符具有右结合性？为什么赋值和三目运算符是右结合的？](#7--哪些运算符具有右结合性为什么赋值和三目运算符是右结合的)
- [8. 🤔 括号 () 如何改变默认的优先级和结合性？](#8--括号--如何改变默认的优先级和结合性)
- [9. 🤔 常见的优先级陷阱有哪些？如何避免？](#9--常见的优先级陷阱有哪些如何避免)
- [10. 🔗 引用](#10--引用)

<!-- endregion:toc -->

## 1. 🎯 本节内容

- 运算符优先级
- 结合性
- 语法分组
- 求值顺序
- 副作用
- 序列点与已排序求值
- 括号的作用边界
- 常见优先级陷阱

## 2. 🫧 评价

- 优先级和结合性并不难，难在它们经常被误当成求值顺序。
- 工程实践中记表不如记原则：可疑表达式一律加括号，并减少副作用。

## 3. 🤔 什么是运算符优先级？它如何影响表达式求值？

运算符优先级描述的是：当一个表达式里出现多种运算符时，编译器如何把它们组织成一棵语法树，也就是先把哪一部分“绑定”在一起。

优先级影响的是表达式的“分组方式”，而不是保证运行时一定按从左到右或从右到左依次求值。

可以把优先级理解成：谁更紧密地贴在操作数上。

- 一元运算符通常比二元运算符更紧。
- 乘除通常比加减更紧。
- 关系与相等比较通常比逻辑与或更紧。

::: code-group

```c [优先级决定分组]
int x = 1;
int y = 2;
int z = 3;

int a = x + y * z;   // 等价于 x +（y * z）。
int b = x + y << z;  // 等价于（x + y）<< z。
```

:::

如果你不确定一个表达式的分组方式，最稳妥的做法是加括号，把意图写死。

## 4. 🤔 什么是结合性？左结合与右结合有何区别？

结合性描述的是：当同一优先级的运算符连续出现时，表达式如何分组。

- 左结合：从左到右分组。
- 右结合：从右到左分组。

结合性同样是“语法分组规则”，不是求值顺序的承诺。

::: code-group

```c [左结合示例]
int x = 10;
int y = 3;
int z = 2;

int a = x - y - z;  // 等价于（x - y）- z。
```

```c [右结合示例]
int a;
int b;
int c = 0;

a = b = c;  // 等价于 a =（b = c）。
```

:::

结合性常见于以下场景：

- 加减乘除、位移、按位与或异或等大多是左结合。
- 赋值、条件运算符 `?:` 以及多数前缀一元运算符是右结合。

## 5. 🤔 为什么 a = b = c 是合法的，而 a + b + c 的求值顺序却不同？

这类问题里有两个经常被混淆的概念：

1. 结合性决定语法分组。
2. 求值顺序决定运行时先算谁后算谁。

先看语法分组：

- 赋值运算符是右结合，所以 `a = b = c` 会被分组为 `a = (b = c)`。
- 加法运算符是左结合，所以 `a + b + c` 会被分组为 `(a + b) + c`。

再看求值顺序：

- 对于 `+` 这类普通二元运算符，C 并不保证一定先求左操作数还是右操作数。
- 因此，即使写成 `(a + b) + c`，也不要在 `a`、`b`、C 里塞进带副作用的表达式来依赖顺序。

::: code-group

```c [⚠️ 分组不等于求值顺序]
int i = 0;
int x = (i++) + (i++);
// ⚠️ 这个表达式包含对同一对象的多次修改，且缺少明确的排序关系，行为未定义。
```

:::

把“如何分组”和“先算哪个”分开理解，才能真正写对。

## 6. 🆚 优先级高是否意味着先求值？副作用与求值顺序的关系是什么？

优先级高不等于一定先求值。优先级和结合性决定的是语法分组，而求值顺序涉及运行时对操作数的实际计算顺序。

| 维度               | 优先级与结合性       | 求值顺序与副作用         |
| ------------------ | -------------------- | ------------------------ |
| 解决的问题         | 表达式如何分组       | 操作数何时被计算         |
| 发生的阶段         | 语法分析阶段         | 运行时阶段               |
| 能否靠记忆避免风险 | 可以通过括号消除歧义 | 不能靠括号保证所有顺序   |
| 与副作用关系       | 间接相关             | 直接相关                 |
| 常见误解           | 优先级高就一定先算   | 看到括号就以为顺序被固定 |

副作用指的是：表达式求值过程中对程序状态的改变，比如对变量赋值、自增自减、函数调用产生的外部影响。

有些运算符会在语言层面提供更明确的“已排序求值”关系，例如：

- `&&` 和 `||`：左侧先求值，并且可能短路。
- 条件运算符 `?:`：条件先求值，然后只求值分支中的一个。
- 逗号运算符 `,`：左侧先求值，再求值右侧。

::: code-group

```c [✅ 利用短路避免危险访问]
typedef struct {
  int size;
} Buffer;

int is_valid(const Buffer* p) {
  return p != NULL && p->size > 0;
}
```

```c [❌ 依赖求值顺序的写法]
int i = 0;
int x = i++ + ++i;
// ❌ 对 i 的多次修改缺少明确的排序关系，行为未定义。
```

:::

经验法则是：把带副作用的操作从复杂表达式里拿出来，让每一步的意图更明确。

## 7. 🤔 哪些运算符具有右结合性？为什么赋值和三目运算符是右结合的？

常见的右结合运算符包括：

- 各类赋值：`=`、`+=`、`-=`、`*=`、`/=`、`%=`、`<<=`、`>>=`、`&=`、`^=`、`|=`。
- 条件运算符：`?:`。
- 多数前缀一元运算符与类型转换，例如 `!x`、`~x`、`++x`、`--x`、`(type)x`、`sizeof x`。

赋值是右结合的主要原因是：链式赋值在语义上很自然，并且赋值表达式本身有值。

::: code-group

```c [链式赋值]
int a;
int b;
int c;

a = b = c = 0;  // 等价于 a =（b =（c = 0））。
```

:::

条件运算符 `?:` 是右结合的主要原因是：它允许把多个条件写成一个嵌套表达式，并且分组方式一致。

::: code-group

```c [三目运算符的右结合]
int grade = 85;
const char* level = grade >= 90 ? "A" : grade >= 60 ? "B" : "C";
// 等价于：grade >= 90 ? "A" :（grade >= 60 ? "B" : "C"）。
```

:::

如果你发现三目嵌套让可读性下降，优先改写为 `if` 语句，而不是强行把逻辑塞进一行。

## 8. 🤔 括号 () 如何改变默认的优先级和结合性？

括号的核心作用是：改变表达式的语法分组，从而覆盖默认的优先级与结合性。

但要注意：括号主要解决“怎么分组”，并不自动保证“先算左边再算右边”。

::: code-group

```c [用括号固定分组]
int x = 1;
int y = 2;
int z = 3;

int a = x + (y << z);  // 强制先做位移，再做加法。
```

```c [⚠️ 括号不等于固定顺序]
int i = 0;
int x = (i++) + (i++);
// ⚠️ 即便加了括号，仍然没有引入明确的排序关系，行为依旧未定义。
```

:::

当你想要强制先后顺序时，更可靠的方法是拆成多条语句，或者使用具有明确排序语义的运算符。

## 9. 🤔 常见的优先级陷阱有哪些？如何避免？

常见陷阱通常来自两类问题：

- 误判优先级导致分组不符合预期。
- 误把分组当成求值顺序，进而引入副作用相关的问题。

::: code-group

```c [❌ 陷阱一：按位与和相等比较]
unsigned int flags = 0x10;

if (flags & 0x10 == 0) {
  // ❌ 解析为 flags &（0x10 == 0）。
}
```

```c [✅ 修正写法]
unsigned int flags = 0x10;

if ((flags & 0x10) == 0) {
  // ...
}
```

```c [❌ 陷阱二：连写比较]
int a = 1;
int b = 2;
int c = 3;

if (a < b < c) {
  // ❌ 解析为（a < b）< c。
  // 其中（a < b）的结果是 0 或 1，然后再与 c 比较。
}
```

```c [✅ 修正写法]
int a = 1;
int b = 2;
int c = 3;

if (a < b && b < c) {
  // ...
}
```

```c [⚠️ 陷阱三：位移与加法]
int x = 1;
int y = 2;
int z = 3;

int v1 = x + y << z;      // 等价于（x + y）<< z。
int v2 = x + (y << z);    // 如果你想表达这个，就显式加括号。
```

:::

避免陷阱的建议：

1. 只要表达式里混用了位运算、比较、逻辑运算，默认加括号。
2. 表达式里尽量不要出现多次自增自减或赋值，尤其不要对同一变量既读又改。
3. 编译时打开告警，例如 `-Wall -Wextra -Wpedantic -Wparentheses`，并把告警当成错误处理。
4. 代码评审时对“聪明的一行表达式”保持警惕，优先可读性。

## 10. 🔗 引用

- [cppreference：C 运算符优先级][1]
- [cppreference：C 求值顺序与副作用][2]
- [GCC：Warning Options，`-Wparentheses` 等告警][3]

[1]: https://en.cppreference.com/w/c/language/operator_precedence
[2]: https://en.cppreference.com/w/c/language/eval_order
[3]: https://gcc.gnu.org/onlinedocs/gcc/Warning-Options.html
