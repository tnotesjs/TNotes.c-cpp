# [0011. 常量与变量](https://github.com/tnotesjs/TNotes.c-cpp/tree/main/notes/0011.%20%E5%B8%B8%E9%87%8F%E4%B8%8E%E5%8F%98%E9%87%8F)

<!-- region:toc -->

- [1. 🎯 本节内容](#1--本节内容)
- [2. 🫧 评价](#2--评价)
- [3. 🤔 什么是变量？它的本质是什么？](#3--什么是变量它的本质是什么)
  - [3.1. 变量的本质](#31-变量的本质)
  - [3.2. 与“变量”相关的重要概念](#32-与变量相关的重要概念)
  - [3.3. 小结](#33-小结)
- [4. 🤔 什么是常量？C 语言中有哪些类型的常量？](#4--什么是常量c-语言中有哪些类型的常量)
- [5. 🤔 如何定义和初始化变量？](#5--如何定义和初始化变量)
- [6. 🤔 变量的作用域和生命周期由什么决定？](#6--变量的作用域和生命周期由什么决定)
- [7. 🆚 字面量常量 vs const 变量 vs #define 宏常量有何区别？](#7--字面量常量-vs-const-变量-vs-define-宏常量有何区别)
- [8. 🤔 未初始化的变量会有什么风险？](#8--未初始化的变量会有什么风险)
- [9. 🤔 常量可以被修改吗？const 的含义是什么？](#9--常量可以被修改吗const-的含义是什么)
- [10. 🤔 为什么变量名不能以数字开头？](#10--为什么变量名不能以数字开头)

<!-- endregion:toc -->

## 1. 🎯 本节内容

- 变量的本质
- 常量的定义与使用
- 变量的作用域和生命周期

## 2. 🫧 评价

本节内容涵盖了变量的本质、常量的定义与使用，以及变量的作用域和生命周期等核心概念。

## 3. 🤔 什么是变量？它的本质是什么？

### 3.1. 变量的本质

在 C 语言中，变量是具有名字和类型的内存对象，用于存储特定类型的数据。

从抽象角度看，变量可视为一块内存区域的具名引用，其类型决定了该内存如何被访问和解释。

### 3.2. 与“变量”相关的重要概念

- 名字：标识这块内存，对人来说便于记忆和理解
- 地址：这块内存在线性地址空间中的位置，例如通过 `&x` 取得
- 值：当前存放在这块内存中的比特模式，按照变量的类型进行解释
- 类型：告诉编译器这块内存里存放的是什么样的数据，可以做什么运算

### 3.3. 小结

在咱们的开发中，变量随处可见，因此，“变量的本质”是非常重要的知识点。

理解变量的本质，有助于后续理解指针、内存布局，以及作用域和生命周期等重要概念，几乎贯穿了整个 C 语言的学习。

## 4. 🤔 什么是常量？C 语言中有哪些类型的常量？

常量指的是在程序运行过程中不能被修改的值，或者说，从程序语义的角度看，应当保持不变的量。

在 C 语言中，常见的常量形式包括：

- 字面量常量：
  - 整数字面量：`0`、`42`、`0xFF`。
  - 浮点字面量：`3.14`、`1e-3`。
  - 字符常量：`'a'`、`'\n'`。
  - 字符串字面量：`"hello"`。
- 枚举常量：
  - 使用 `enum` 定义，枚举成员在编译期具有确定的整型值。
- `const` 修饰的变量：
  - 例如 `const int max_count = 100`，从语义上看是只读的。
- 宏常量：
  - 使用 `#define` 定义的名字，在预处理阶段通过文本替换展开。

不同形式的常量在类型检查、可调试性以及是否占用存储空间等方面都有差异，后续小节会专门比较。

## 5. 🤔 如何定义和初始化变量？

在 C 中，定义变量时通常需要同时指定类型和名字，还可以选择是否在定义时进行初始化：

- 只定义不初始化：
  - 如 `int count`、`double price`。
  - 局部变量如果不显式初始化，其初始值是不确定的。
- 定义并初始化：
  - 如 `int count = 0`、`double price = 9.99`。
  - 建议在大多数情况下都进行初始化，以避免未定义行为。
- 声明与定义的区分：
  - 使用 `extern` 关键字可以只声明变量，不分配存储。
  - 例如 `extern int g_count` 表示变量在其他翻译单元中定义。

良好的实践是：

- 尽量在变量首次使用前，靠近使用处定义。
- 能初始化就不要留成未初始化状态。
- 全局变量如果不是必须，尽量少用，以降低耦合。

## 6. 🤔 变量的作用域和生命周期由什么决定？

变量的作用域决定了在哪里可以使用这个名字，变量的生命周期则决定了这块内存从什么时候开始存在、什么时候被销毁。

- 作用域：主要由语法块决定。
  - 在函数体或一对花括号内部定义的变量，只在该块内可见。
  - 在文件作用域定义的变量，作用域可以扩展到整个翻译单元，或通过 `extern` 在其他文件中可见。
- 生命周期：主要由存储类型决定。
  - 自动存储周期：典型的局部变量，进入块时分配，离开块时销毁。
  - 静态存储周期：典型的全局变量和使用 `static` 声明的变量，从程序开始到程序结束始终存在。

例如：

```c
void foo(void) {
  int x = 0;      // x 只在 foo 内可见，进入 foo 时创建，离开时销毁
  static int cnt; // cnt 只在 foo 内可见，但生命周期从程序开始到结束
}
```

理解作用域和生命周期，是写出可维护代码和避免悬垂引用、内存泄漏等问题的基础。

## 7. 🆚 字面量常量 vs const 变量 vs #define 宏常量有何区别？

这三种常量形式在语法层级、类型安全、可调试性等方面都有明显不同：

| 特性 | 字面量常量 | const 变量 | `#define` 宏常量 |
| --- | --- | --- | --- |
| 是否有类型 | 有，编译器能推导 | 有，具备明确的类型声明 | 无，只是纯文本替换 |
| 作用域 | 随使用位置而变化 | 遵循 C 的作用域规则 | 一般从定义处到文件结尾 |
| 存储空间 | 可能被嵌入指令中 | 通常会有一个实际的对象存储 | 不一定产生对象 |
| 调试友好 | 一般，可看到字面值 | 更好，可以在调试器中单独观察 | 较差，展开后不易追踪 |
| 类型检查 | 有 | 有 | 弱，可能导致隐式错误 |

常见的对比示例：

::: code-group

```c [❌ 仅用宏常量]
#define PI 3.14

double area(double r) {
  return PI * r * r; // 文本替换，可能导致调试和类型问题
}
```

```c [✅ 使用 const 变量]
const double PI = 3.14;

double area(double r) {
  return PI * r * r; // 有明确类型，编译器可做更多检查和优化
}
```

:::

一般来说，在需要类型安全和良好调试体验的场景，更推荐使用 `const` 变量或枚举常量，而不是宏常量。

## 8. 🤔 未初始化的变量会有什么风险？

在 C 语言中，局部变量如果没有显式初始化，其初始值是未定义的，直接使用会产生未定义行为，这是一类非常常见且危险的错误。

::: code-group

```c [❌ 使用未初始化局部变量]
int sum(void) {
  int x;       // 未初始化，值是随机的
  return x + 1; // 未定义行为
}
```

```c [✅ 始终初始化局部变量]
int sum(void) {
  int x = 0;   // 明确初始化
  return x + 1;
}
```

:::

需要特别注意：

- 局部自动变量如果不显式初始化，值是不确定的。
- 全局变量和具有静态存储周期的变量，如果不显式初始化，会被默认初始化为零。

推荐的习惯是：

- 所有局部变量在定义时就给出合理的初始值。
- 对于复杂类型，优先使用初始化而不是先定义再逐字段赋值。

## 9. 🤔 常量可以被修改吗？const 的含义是什么？

`const` 关键字表示不能通过该标识符修改对象的值，但并不一定保证底层内存绝对不可变。

- 对于 `const int x = 10`，编译器会禁止通过 `x` 进行赋值操作。
- 如果通过强制类型转换去掉 `const` 再修改，则会触发未定义行为，特别是对于放在只读内存中的对象。
- 对指针来说，`const` 可以修饰指向的对象，也可以修饰指针本身，语义不同。

::: code-group

```c [⚠️ const 与指针]
const int *p;      // 指向常量的指针，不能通过 p 修改 *p
int *const q = &g; // 常量指针，本身地址不能改，但可以修改 *q
```

:::

因此，可以简单理解为：

- `const` 更像是一种只读承诺，用来帮助编译器做检查和优化。
- 通过违反承诺的方式去修改这块内存，即使语法上能写出来，在语义上也可能是未定义行为。

## 10. 🤔 为什么变量名不能以数字开头？

C 语言的标识符命名规则要求，首字符必须是字母或下划线，不能是数字，这与词法分析过程密切相关。

- 如果允许以数字开头，编译器在扫描 `123abc` 这一串字符时，就无法区分它是数字常量还是标识符。
- 当前规则下，编译器可以简单地把以数字开头的序列都当作数值字面量处理，以字母或下划线开头的当作标识符处理，从而简化实现。

从可读性的角度看，以数字开头的名字本身也容易与数值混淆，因此，即便某些语言在语法上允许，也通常不推荐这样做。
