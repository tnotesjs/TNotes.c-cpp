# [0007. C 语言历史](https://github.com/tnotesjs/TNotes.c/tree/main/notes/0007.%20C%20%E8%AF%AD%E8%A8%80%E5%8E%86%E5%8F%B2)

<!-- region:toc -->

- [1. 🎯 本节内容](#1--本节内容)
- [2. 🫧 评价](#2--评价)
- [3. 🤔 C 语言是如何诞生的？](#3--c-语言是如何诞生的)
- [4. 🤔 C 语言的设计目标是什么？](#4--c-语言的设计目标是什么)
- [5. 🤔 C 语言与 B 语言、ALGOL 68 有何关系？](#5--c-语言与-b-语言algol-68-有何关系)
  - [5.1. ALGOL 60、ALGOL 68](#51-algol-60algol-68)
  - [5.2. BCPL、B](#52-bcplb)
  - [5.3. C](#53-c)
  - [5.4. 小结](#54-小结)
- [6. 🤔 Unix 操作系统与 C 语言的发展有何关联？](#6--unix-操作系统与-c-语言的发展有何关联)
- [7. 🆚 `K&R C` vs `ANSI C`（C89）](#7--kr-c-vs-ansi-cc89)
- [8. 🤔 C 语言标准化经历了哪些重要阶段？](#8--c-语言标准化经历了哪些重要阶段)
  - [8.1. `C89` 或 `C90`](#81-c89-或-c90)
  - [8.2. `C99`](#82-c99)
  - [8.3. `C11`](#83-c11)
  - [8.4. `C17` 以及之后](#84-c17-以及之后)
  - [8.5. 小结](#85-小结)
- [9. 🤔 学习时应该选择 C 语言的哪个版本进行学习呢？](#9--学习时应该选择-c-语言的哪个版本进行学习呢)
  - [9.1. 版本选择建议](#91-版本选择建议)
  - [9.2. 学习策略](#92-学习策略)
    - [基础语法阶段（重点关注）](#基础语法阶段重点关注)
    - [特性学习优先级](#特性学习优先级)
    - [编译器设置建议](#编译器设置建议)
  - [9.3. 注意事项](#93-注意事项)
  - [9.4. 小结](#94-小结)
- [10. 🤔 为什么 C 语言被称为“中级语言”？](#10--为什么-c-语言被称为中级语言)
- [11. 🤔 C 语言对后续编程语言产生了哪些影响？](#11--c-语言对后续编程语言产生了哪些影响)
- [12. 🔗 引用](#12--引用)

<!-- endregion:toc -->

## 1. 🎯 本节内容

- C 语言历史简介

## 2. 🫧 评价

关于 C 的起源，网上科普视频有很多，感兴趣可以搜来看看，喜欢阅读文本的话，可以重点瞅瞅 [维基百科 - C 语言][1] 这篇文章，内容比较全面，且有大量引用资料，可以深入挖掘。

笔记中介绍到的关于 C 语言的一些版本，这些内容对我们实际开发和接下来的学习或许会有点儿影响，如果对版本选择有疑问，可以快速过一下。

## 3. 🤔 C 语言是如何诞生的？

C 语言诞生于二十世纪七十年代初（通常公认为 1972 年），主要起源于贝尔实验室。

一个比较常见的时间线是：

- 为了在小型机上开发新的操作系统，研究人员需要一门比汇编语言更高效，又能直接操作硬件的语言。
- [丹尼斯·里奇][2] 与 [肯·汤普森][3] 在前人工作的基础上，设计并实现了 C 语言，最初主要用于编写 Unix 内核和工具。
- 随着 Unix 在学术界和工业界的传播，C 语言也一起被广泛传播，出现了大量基于 C 编写的系统软件。

C 一开始并不是作为教学语言出现的，而是为了满足工程团队在真实项目中的需求，这一点也深刻影响了它之后的发展路线。

## 4. 🤔 C 语言的设计目标是什么？

从历史资料和实际特性来看，C 语言的大致设计目标可以概括为：

- 贴近底层：让程序员可以方便地操纵内存、位和操作系统资源。
- 保持小而精：语法简单，核心概念不多，方便理解和实现。
- 生成高效的机器代码：让用 C 写出的程序和汇编程序的性能差距尽量小。
- 具备一定的可移植性：通过少量改动就能在不同硬件和操作系统上编译运行。

因此，C 常被形容为既像高级语言，又像可移植的汇编语言。

## 5. 🤔 C 语言与 B 语言、ALGOL 68 有何关系？

C 语言并不是凭空出现的，而是站在多门语言的肩膀上发展而来。

### 5.1. ALGOL 60、ALGOL 68

- 提供了较为先进的语法结构和块结构概念。
- 影响了许多后续语言，包括 B 和 C。

### 5.2. BCPL、B

- BCPL 是一种为系统编程设计的语言。
- 肯汤普森在 BCPL 的基础上设计了 B 语言。
- B 语言已经可以用于系统开发，但在类型系统和表达能力上仍有限。

### 5.3. C

- 可以视为 B 的类型化继承者，和 ALGOL 系谱有明显的亲缘关系。
- 在语法上吸收了 ALGOL 系列的块结构，同时延续了 B 在系统编程上的实用性。

### 5.4. 小结

可以简单理解为：C 继承了 B 的用途与整体风格，也借鉴了 ALGOL 68 的一些语法思想，在此基础上强化了类型系统。

## 6. 🤔 Unix 操作系统与 C 语言的发展有何关联？

Unix 的发展与 C 语言几乎是同步推进的，两者互相成就。

- 早期的 Unix 内核最初主要使用汇编语言实现，维护成本高，移植困难。
- 随着 C 语言日趋成熟，开发者开始用 C 重写大部分 Unix 代码，只在少量和硬件高度相关的部分使用汇编来实现。
- 用 C 编写的 Unix 更容易移植到新的硬件平台，也更便于多人协作和长期维护。

由于 Unix 在高校和企业广泛传播，学习和使用 Unix 的人也顺理成章地接触并学习了 C 语言，这极大加速了 C 的普及。

## 7. 🆚 `K&R C` vs `ANSI C`（C89）

在标准化之前，业界广泛使用的是以经典教材为代表的 `K&R C`，后来才有正式的 `ANSI C` 标准，可以从几个角度对比这两个阶段：

| 特性 | `K&R C` | `ANSI C`（C89） |
| --- | --- | --- |
| 函数声明风格 | 常见省略参数类型或返回类型 | 要求明确的原型声明，提升类型检查能力 |
| 标准库 | 约定为主，细节实现各不相同 | 由标准严格规定，接口更加一致 |
| 可移植性 | 不同编译器之间差异较大 | 更强调跨平台行为一致性 |
| 语法细节 | 某些语法尚不规范 | 修订模糊之处，引入更多保留关键字 |

总体来说，`ANSI C` 在不破坏 `K&R C` 核心风格的前提下，增强了类型安全性和可移植性，为后续标准打下了基础。

## 8. 🤔 C 语言标准化经历了哪些重要阶段？

C 语言经历了多次标准化工作，其中几版标准特别重要：

### 8.1. `C89` 或 `C90`

- 第一个广泛认可的国际标准，也常被统称为 `ANSI C`。

### 8.2. `C99`

- 引入了更多现代特性，如可变长数组、行内声明、更丰富的标准库支持。

### 8.3. `C11`

- 增加了对多线程和并发的支持，提升了语言在现代系统中的适用性。

### 8.4. `C17` 以及之后

- 主要是勘误和小幅更新，在不破坏已有代码基础上修正问题。

### 8.5. 小结

理解这些标准的演进，有助于阅读老代码时判断其写作年代，也有助于在新项目中合理选择编译器标准选项。

## 9. 🤔 学习时应该选择 C 语言的哪个版本进行学习呢？

### 9.1. 版本选择建议

C11 是当前最平衡、最实用的选择：

1. 普及率高：所有主流编译器（GCC, Clang, MSVC）都完全支持。
2. 特性完整：包含了 C99 大部分实用特性，并引入了关键的 `_Generic`（泛型选择）、`_Thread_local` 等。
3. 教材兼容：绝大多数经典教材（如《C Primer Plus》）的内容在 C11 下完全有效。
4. 就业友好：工业界项目大多基于 C89/C99/C11，学习 C11 能平滑过渡。

### 9.2. 学习策略

学习 C 语言时，建议以 `C11` 标准作为核心学习目标，同时了解它与 `C99`/`C89` 的关键差异。

#### 基础语法阶段（重点关注）

变量、运算符、控制流、函数、数组、指针、结构体 —— 这些核心语法在 C89 之后基本稳定。任何现代标准都适用。

#### 特性学习优先级

必学（所有版本通用）：指针、内存管理、标准 I/O、字符串处理。

重点学（C99/C11）：

- `//` 单行注释（C99 引入）
- 变量声明位置随意（C99 取消必须放在块开头的限制）
- `long long` 类型和 `<stdint.h>`（C99 引入，用于明确整数宽度）
- 布尔类型 `_Bool` 和 `<stdbool.h>`（C99 引入）

了解即可（C11 新特性）：

- `_Generic`：用于泛型编程的初级支持
- `<threads.h>`：标准线程库（但实际项目中更多用 POSIX 或系统原生 API）
- 边界检查函数（如 `gets_s`）和安全特性

#### 编译器设置建议

```bash
# GCC/Clang 常用编译选项
gcc -std=c11 -pedantic -Wall -Wextra -o program program.c
```

- `-std=c11`：指定 C11 标准
- `-pedantic`：严格遵循标准，拒绝编译器扩展
- `-Wall -Wextra`：开启大量警告，帮助养成好习惯

### 9.3. 注意事项

需要警惕的“过时”内容。

- K&R 风格的函数声明（如 `int func(a, b) int a; int b; {}`）：了解即可，不要在新代码中使用。
- 不安全的函数：如 `gets()`（已从 C11 标准库移除）、`sprintf()`（应改用 `snprintf()`）。

### 9.4. 小结

- 初学者：直接按 C11 标准学习，使用现代教材和编译器。
- 维护老代码：可能需要了解 C89/C99 的特定写法。
- 新项目开发：明确指定 C11 或 C17（C17 是 C11 的缺陷修复版，无新功能）。
- 考试/认证：确认考试要求的标准版本（有些学校仍以 C89 为基准）。

C 语言的核心思想是“信任程序员”，所以无论哪个版本，理解底层原理（如内存布局、指针运算）比记住语法细节更重要。选择一个现代标准开始，然后通过实践和阅读优秀代码来深化理解。

## 10. 🤔 为什么 C 语言被称为“中级语言”？

很多资料会把 C 称为中级语言，这个说法并不是官方术语，而是对其抽象层次的一种形象描述。

- 相对汇编：C 提供了更高层次的抽象，能使用结构体、函数、模块等结构组织程序。
- 相对许多现代高级语言：C 又保留了非常多底层细节，如显式内存管理、指针算术、位运算。

因此，C 一方面能让开发者较为直接地掌控硬件资源，另一方面又比纯汇编更易编写和维护，介于高级语言与低级语言之间。

## 11. 🤔 C 语言对后续编程语言产生了哪些影响？

C 语言对后续众多语言有深远影响，体现在语法风格、编程模型以及生态等多个维度：

- 语法层面：许多现代语言沿用了 C 风格的语句块、运算符和优先级规则，如 `C++`、`Java`、`C#`、`JavaScript` 等。
- 模型层面：指针、数组、结构体、函数等概念在系统编程领域几乎成为事实标准。
- 工具链层面：编译、链接、目标文件、静态库、动态库等概念，也大多沿用了 C 时代形成的习惯。

即使在使用其他语言时，了解 C 的历史和设计取舍，也有助于更好地理解操作系统、编译器以及许多运行时环境的底层行为。

## 12. 🔗 引用

- [维基百科 - C 语言][1]
- [维基百科 - 丹尼斯·里奇][2]
- [维基百科 - 肯·汤普森][3]

[1]: https://zh.wikipedia.org/zh-cn/C%E8%AF%AD%E8%A8%80
[2]: https://zh.wikipedia.org/wiki/%E4%B8%B9%E5%B0%BC%E6%96%AF%C2%B7%E9%87%8C%E5%A5%87
[3]: https://zh.wikipedia.org/wiki/%E8%82%AF%C2%B7%E6%B1%A4%E6%99%AE%E9%80%8A
