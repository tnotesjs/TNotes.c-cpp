# [0010. C 语言中的数据类型](https://github.com/tnotesjs/TNotes.c-cpp/tree/main/notes/0010.%20C%20%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B)

<!-- region:toc -->

- [1. 🎯 本节内容](#1--本节内容)
- [2. 🫧 评价](#2--评价)
- [3. 🤔 C 语言有哪些基本数据类型？](#3--c-语言有哪些基本数据类型)
  - [3.1. 基本类型](#31-基本类型)
  - [3.2. 派生类型](#32-派生类型)
  - [3.3. 小结](#33-小结)
- [4. 🤔 什么是类型修饰符（`signed`、`unsigned`、`short`、`long`）？](#4--什么是类型修饰符signedunsignedshortlong)
- [5. 🤔 各数据类型的存储大小和取值范围如何确定？](#5--各数据类型的存储大小和取值范围如何确定)
- [6. 🆚 `int` vs `long` vs `long long`（在不同平台上的差异）](#6--int-vs-long-vs-long-long在不同平台上的差异)
- [7. 🤔 `void` 类型是什么？有什么作用？](#7--void-类型是什么有什么作用)
  - [7.1. 函数返回类型为 `void`](#71-函数返回类型为-void)
  - [7.2. 指针类型 `void*`](#72-指针类型-void)
  - [7.3. 函数参数为 `void`](#73-函数参数为-void)
  - [7.4. 小结](#74-小结)
- [8. 🤔 什么是 `typedef`？它如何创建类型别名？](#8--什么是-typedef它如何创建类型别名)
- [9. 🤔 字符类型 `char` 是有符号还是无符号？](#9--字符类型-char-是有符号还是无符号)
  - [9.1. `char` 类型的符号性（signedness）](#91-char-类型的符号性signedness)
  - [9.2. 常见的移植性问题](#92-常见的移植性问题)
  - [9.3. 小结](#93-小结)
- [10. 🆚 `float` vs `double` vs `long double`（精度与存储层面的差异）](#10--float-vs-double-vs-long-double精度与存储层面的差异)
- [11. 🤔 如何查看某个类型在当前平台上的大小？](#11--如何查看某个类型在当前平台上的大小)
- [12. 💻 demos.1 - C 语言中的数据类型](#12--demos1---c-语言中的数据类型)

<!-- endregion:toc -->

## 1. 🎯 本节内容

- 两大类数据类型（基本类型和派生类型）
- 类型修饰符
- 不同数据类型的存储空间大小
- `void` 类型
- `typedef` 创建类型别名
- `char` 类型的符号性（signedness）
- 不同浮点数类型的精度和存储差异
- `sizeof` 运算符查看类型大小

## 2. 🫧 评价

对 C 语言中和数据类型相关的知识点做了汇总，涵盖了从基本类型到平台差异等关键概念。

## 3. 🤔 C 语言有哪些基本数据类型？

在标准 C 中，所有类型大致可以分为两大类。

### 3.1. 基本类型

- 整型：`char`、`short`、`int`、`long`、`long long`，以及它们对应的无符号形式
- 浮点型：`float`、`double`、`long double`
- 枚举类型：使用 `enum` 把一组离散的整型常量放在一起
- 空类型：`void`，表示无值

### 3.2. 派生类型

- 指针、数组、结构体、共用体、函数类型等，由基本类型组合得到

### 3.3. 小结

基本数据类型和派生数据类型都很重要，前者提供了构建数据的原子单位，后者则是通过组合这些原子单位来表达更复杂的数据结构和行为。

本节主要聚焦整型、浮点型和 `void` 这几类在 C 中最常用的基础类型。

## 4. 🤔 什么是类型修饰符（`signed`、`unsigned`、`short`、`long`）？

类型修饰符用来在不改变类型“种类”的前提下，调整类型的符号属性或宽度。

符号修饰符：

- `signed`：表示有符号，可以表示正数、零和负数。
- `unsigned`：表示无符号，只能表示零和正数。

宽度修饰符：

- `short`：一般比 `int` 窄。
- `long`、`long long`：一般比 `int` 宽。

通过组合这些修饰符，可以得到多种整型，如 `unsigned int`、`long int`、`unsigned long long` 等。具体大小由实现决定，但必须满足标准规定的相对大小关系。

## 5. 🤔 各数据类型的存储大小和取值范围如何确定？

C 标准并不直接规定每种类型必须占用多少字节，而是给出一组约束，例如：

- `sizeof(char)` 必须是 1
- `sizeof(short)` 不大于 `sizeof(int)`
- `sizeof(int)` 不大于 `sizeof(long)`
- 各种整型必须满足标准规定的最小取值范围（例如 `int` 至少能表示一定范围内的整数）

在具体实现中，编译器会根据目标平台的字长和体系结构做出具体选择，因此不同平台上类型大小可能不同。

在程序中，可以通过 `sizeof` 运算符动态查询某个类型或对象在当前平台上的大小，从而写出更具可移植性的代码。

## 6. 🆚 `int` vs `long` vs `long long`（在不同平台上的差异）

在实际开发中，`int`、`long`、`long long` 的大小未必相同，常见的平台差异可以大致归纳为：

| 模型  | `int` 大小 | `long` 大小 | `long long` 大小 |
| ----- | ---------- | ----------- | ---------------- |
| LP32  | 16 位      | 32 位       | 64 位            |
| ILP32 | 32 位      | 32 位       | 64 位            |
| LP64  | 32 位      | 64 位       | 64 位            |

许多桌面和服务器平台采用的是 `ILP32` 或 `LP64` 模型，因此：

- 在 `ILP32` 上，`int` 和 `long` 通常都是 32 位。
- 在 `LP64` 上，`int` 通常是 32 位，而 `long` 和 `long long` 是 64 位。

因此，在需要精确控制整数位宽时，更推荐使用标准头文件中的固定宽度类型，如 `int32_t`、`int64_t` 等。

## 7. 🤔 `void` 类型是什么？有什么作用？

`void` 表示“没有值”或“不关心具体类型”，在 C 中有几个常见用法：

### 7.1. 函数返回类型为 `void`

函数返回类型为 `void` 表示函数没有返回值，例如 `void foo` 只负责执行操作。

### 7.2. 指针类型 `void*`

指针类型 `void*` 表示指向某种未知类型的指针，常用于通用接口和内存管理函数中。

使用前需要显式转换成具体类型指针。

### 7.3. 函数参数为 `void`

在函数声明中将参数写作 `void` 表示函数不接受任何参数。

### 7.4. 小结

合理使用 `void` 可以让接口语义更清晰，但滥用 `void*` 也会削弱类型检查，需要谨慎权衡。

## 8. 🤔 什么是 `typedef`？它如何创建类型别名？

`typedef` 用来给已有类型起一个新的名字，也就是类型别名，主要用途是：

- 简化复杂声明，例如函数指针、结构体指针等。
- 提高可读性，让类型名称更贴近业务语义。
- 为平台相关类型统一起名，便于在不同平台上切换具体实现。

使用方式大致是：

- 把原本的类型说明写在 `typedef` 后面。
- 在最右侧放上新类型名。

例如：

- `typedef unsigned long size_type`：为无符号长整型起别名。
- `typedef int bool`：在不使用标准库时手工模拟布尔类型。

## 9. 🤔 字符类型 `char` 是有符号还是无符号？

标准规定，`char` 是否有符号由具体实现决定，只能保证 `signed char` 必定是有符号的，而 `unsigned char` 必定是无符号的。

### 9.1. `char` 类型的符号性（signedness）

在 C 语言中，`char` 类型的符号性（signedness）是由编译器实现决定的，也就是说：

- 在某些平台或编译器下，`char` 等价于 `signed char`（取值范围通常是 `-128` 到 `127`）
- 而在另一些平台或编译器下，`char` 等价于 `unsigned char`（取值范围通常是 `0` 到 `255`）

因此，当你用 `char` 来存储非文本的原始字节数据（比如图像像素、音频采样、网络协议包等二进制数据）时，可能会遇到以下问题：

假设你从文件中读取一个字节 `0xFF`（即十进制 255）存入 `char c`：

- 如果 `char` 被视作是无符号的，那么 `c == 255`
- 如果 `char` 被视作是有符号的，那么 `c == -1`（因为 `0xFF` 在补码中表示 `-1`）

这会导致：

- 数值解释错误：比如在计算校验和、解析协议字段时出错
- 比较或运算异常：例如 `if (c > 0)` 在有符号情况下对 `0xFF` 会判断为 `false`
- 跨平台行为不一致：同一段代码在不同系统上表现不同

### 9.2. 常见的移植性问题

- 如果将 `char` 用于存放纯二进制数据，如图像、音频等，在同平台 A 上它可能被当成有符号来处理，在平台 B 上则被当成无符号来处理，进而导致跨平台行为不一致的问题。
- 参与算术运算或比较时，如果 `char` 被视为有符号类型，负值的解释方式会与期望不符。

### 9.3. 小结

综上，建议的实践是：当处理二进制数据（raw bytes） 时，应显式使用 `unsigned char`，以确保每个字节都被解释为 `0–255` 的无符号值，避免平台差异带来的不确定性。

- 当只存放文本字符时，使用普通 `char`
- 当存放任意字节数据时，明确使用 `unsigned char`

## 10. 🆚 `float` vs `double` vs `long double`（精度与存储层面的差异）

在大多数采用 IEEE 浮点标准的平台上，三种浮点类型的典型特性如下：

| 类型        | 典型字节数 | 有效数字位数   | 适用场景             |
| ----------- | ---------- | -------------- | -------------------- |
| float       | 4          | 约 6 到 7 位   | 内存敏感、粗略计算   |
| double      | 8          | 约 15 到 16 位 | 一般数值计算默认选项 |
| long double | 8 或 16    | 实现相关       | 需要更高精度的场景   |

- `float` 占用空间小，但精度有限，容易累积误差
- `double` 是多数数值算法的默认选择
- `long double` 是否比 `double` 更精确，需要查阅具体编译器文档

由于浮点运算本身存在舍入误差，比较两个浮点数是否相等时，通常需要引入一个允许误差范围，而不是直接使用相等比较。

## 11. 🤔 如何查看某个类型在当前平台上的大小？

在 C 程序中，可以使用 `sizeof` 运算符查看某个类型或对象在当前平台上的大小，单位通常是字节。

常见用法有：

- `sizeof int` 或 `sizeof x`：返回对应类型或变量的大小。
- 搭配 `printf` 输出检查结果，例如在 `printf` 中使用 `zu` 打印无符号大小。

在调试或做跨平台开发时，建议写一个小程序，把常用类型的大小全部打印出来，并在需要精确控制二进制布局时，只使用那些大小已经验证过的类型。

## 12. 💻 demos.1 - C 语言中的数据类型

::: code-group

<<< ./demos/1/1.c

<<< ./demos/1/2.c

<<< ./demos/1/3.c

<<< ./demos/1/4.c

<<< ./demos/1/5.c

<<< ./demos/1/6.c

<<< ./demos/1/7.c

<<< ./demos/1/8.c

<<< ./demos/1/9.c

<<< ./demos/1/10.c

:::

| 文件 | 备注                         |
| ---- | ---------------------------- |
| 1.c  | 基本整型的大小（单位：字节） |
| 2.c  | 有符号与无符号整型           |
| 3.c  | 整型的取值范围               |
| 4.c  | 浮点型的大小和精度           |
| 5.c  | char 类型的符号性演示        |
| 6.c  | typedef 类型别名演示         |
| 7.c  | void 类型的应用              |
| 8.c  | 浮点数精度差异演示           |
| 9.c  | 各类型变量的实际使用示例     |
| 10.c | 当前平台数据模型             |
